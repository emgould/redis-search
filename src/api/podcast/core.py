"""
Podcast Core Service - Base service with core utilities.
Provides foundation for search and discovery operations.
"""

from typing import Any

from api.podcast.auth import Auth
from api.podcast.models import MCEpisodeItem, MCPodcastItem
from utils.get_logger import get_logger
from utils.redis_cache import RedisCache

# Cache configuration - 1 hour for podcast data
CacheExpiration = 60 * 60  # 1 hour
PodcastCache = RedisCache(
    defaultTTL=CacheExpiration,
    prefix="podcast",
    verbose=False,
    isClassMethod=True,
    version="1.0.0",  # Added mc_id and mc_type to podcasts and episodes
)
PodcastFunctionCache = RedisCache(
    defaultTTL=60 * 60,  # 1 hour
    prefix="podcast_func",
    verbose=False,
    isClassMethod=False,
    version="1.3.0",  # Updated podcast search sorting to use weighted title matching with Levenshtein distance
)
logger = get_logger(__name__)


class PodcastService(Auth):
    """
    Base Podcast service with core utilities.
    Provides foundation for search and discovery operations.
    """

    def _safe_episode_count(self, episode_count: Any) -> int:
        """
        Safely convert episode_count to a non-negative integer.

        Args:
            episode_count: Episode count value (may be None, string, or int)

        Returns:
            Non-negative integer episode count, or 0 if invalid
        """
        try:
            if episode_count is not None:
                count = int(episode_count)
                return max(0, count)
            return 0
        except (ValueError, TypeError):
            return 0

    def _has_valid_image(self, podcast_data: dict | MCPodcastItem) -> bool:
        """
        Check if podcast has a valid image URL.

        Args:
            podcast_data: Processed podcast dictionary or MCPodcastItem object

        Returns:
            True if podcast has a valid image URL, False otherwise
        """
        # Check both image and artwork fields
        if isinstance(podcast_data, MCPodcastItem):
            image_url = podcast_data.image
            artwork_url = podcast_data.artwork
        else:
            image_url = podcast_data.get("image")
            artwork_url = podcast_data.get("artwork")

        # A podcast has a valid image if either field contains a non-empty URL
        # that starts with http:// or https://
        def is_valid_url(url: Any) -> bool:
            if not url or not isinstance(url, str):
                return False
            url = url.strip()
            return url.startswith(("http://", "https://")) and len(url) > 10

        return bool(is_valid_url(image_url) or is_valid_url(artwork_url))

    def _process_podcast_item(self, podcast_data: dict[str, Any]) -> MCPodcastItem:
        """
        Process and normalize a podcast item from PodcastIndex.

        Args:
            podcast_data: Raw podcast data from PodcastIndex API

        Returns:
            MCPodcastItem with standardized fields and auto-generated mc_id/mc_type
        """
        podcast_id = podcast_data.get("id")
        result_dict = {
            "id": podcast_id,
            "title": podcast_data.get("title", ""),
            "url": podcast_data.get("url", ""),
            "site": podcast_data.get("site"),
            "description": podcast_data.get("description"),
            "author": podcast_data.get("author"),
            "owner_name": podcast_data.get("owner_name"),
            "image": podcast_data.get("image"),
            "artwork": podcast_data.get("artwork"),
            "last_update_time": podcast_data.get("last_update_time"),
            "trend_score": podcast_data.get("trend_score"),
            "language": podcast_data.get("language"),
            "categories": podcast_data.get("categories", {}),
            "episode_count": podcast_data.get("episode_count", 0),
            "itunes_id": podcast_data.get("itunes_id"),
            "spotify_url": podcast_data.get("spotify_url"),
            "podcast_guid": podcast_data.get("podcast_guid"),
            "relevancy_score": podcast_data.get("relevancy_score"),
            "source_id": str(podcast_id) if podcast_id is not None else None,
        }
        # mc_id and mc_type are automatically generated by the MCPodcastItem model validator
        return MCPodcastItem.model_validate(result_dict)

    def _process_episode_item(self, episode_data: dict[str, Any]) -> MCEpisodeItem:
        """
        Process and normalize an episode item from PodcastIndex.

        Args:
            episode_data: Raw episode data from PodcastIndex API

        Returns:
            MCEpisodeItem with standardized fields and auto-generated mc_id/mc_type
        """
        episode_id = episode_data.get("id")
        result_dict = {
            "id": episode_id,
            "title": episode_data.get("title", ""),
            "description": episode_data.get("description"),
            "link": episode_data.get("link"),
            "guid": episode_data.get("guid"),
            "date_published": episode_data.get("date_published"),
            "enclosure_url": episode_data.get("enclosure_url"),  # This is the playback URL
            "enclosure_type": episode_data.get("enclosure_type"),
            "enclosure_length": episode_data.get("enclosure_length"),
            "duration_seconds": episode_data.get("duration_seconds"),
            "explicit": episode_data.get("explicit"),
            "episode_type": episode_data.get("episode_type"),
            "season": episode_data.get("season"),
            "episode": episode_data.get("episode"),
            "feed_id": episode_data.get("feed_id"),
            "feed_title": episode_data.get("feed_title"),
            "image": episode_data.get("image"),
            "source_id": str(episode_id) if episode_id is not None else None,
        }
        # mc_id and mc_type are automatically generated by the MCEpisodeItem model validator
        return MCEpisodeItem.model_validate(result_dict)
